/*
 * [New BSD License]
 * Copyright (c) 2011, Brackit Project Team <info@brackit.org>  
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the <organization> nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package org.brackit.server.store.page.bracket;

import org.brackit.server.node.XTCdeweyID;

/**
 * Class representing a sequence of bracket nodes. It consists of a LowID (which
 * is stored uncompressed) and BracketKeys with corresponding data records.
 * 
 * @author Martin Hiller
 * 
 */
public class BracketNodeSequence {

	public static final int LOW_KEY_OFFSET = -1;

	private final XTCdeweyID lowKey;

	private final byte[] data;

	private final int numberOfDataRecords;

	/**
	 * Constructs a BracketNodeSequence from a single node.
	 * 
	 * @param deweyID
	 *            the node's DeweyID
	 * @param value
	 *            the node's value
	 * @param valueLengthFieldIncluded
	 *            indicate whether the length field ist already included in the
	 *            given value byte arary
	 * @return the BracketNodeSequence
	 */
	public static BracketNodeSequence fromSinlgeNode(XTCdeweyID deweyID,
			byte[] value, boolean valueLengthFieldIncluded) {

		byte[] physicalLowID = deweyID.toBytes();
		int lowIDLength = physicalLowID.length;
		BracketKey.Type lowIDType = (deweyID.isAttribute() ? BracketKey.Type.ATTRIBUTE
				: BracketKey.Type.DATA);

		if (lowIDLength > 255) {
			throw new RuntimeException("StartDeweyID is too long!");
		}

		byte[] valueLength = null;
		if (!valueLengthFieldIncluded) {
			valueLength = BracketPage.getValueLengthField(value, false);
		} else {
			valueLength = new byte[0];
		}

		int dataLength = 1 + lowIDLength + 1 + valueLength.length
				+ value.length;

		byte[] data = new byte[dataLength];
		int currentOffset = 0;
		data[currentOffset++] = (byte) lowIDLength;
		System.arraycopy(physicalLowID, 0, data, currentOffset, lowIDLength);
		currentOffset += lowIDLength;
		data[currentOffset++] = (byte) lowIDType.getPhysicalValue();
		System.arraycopy(valueLength, 0, data, currentOffset,
				valueLength.length);
		currentOffset += valueLength.length;
		System.arraycopy(value, 0, data, currentOffset, value.length);

		return new BracketNodeSequence(data, 1);

	}

	/**
	 * Creates a BracketNodeSequence from the given internal byte representation
	 * 
	 * @param internalRepresentation
	 *            internal byte representation (is generated by the bracket
	 *            page)
	 * @param numberOfDataRecords
	 *            gives the number of data records (values) included in this
	 *            sequence
	 */
	protected BracketNodeSequence(byte[] internalRepresentation,
			int numberOfDataRecords) {
		this.data = internalRepresentation;
		this.numberOfDataRecords = numberOfDataRecords;
		this.lowKey = readLowKey();
	}

	/**
	 * Reads the low key from the data array.
	 * 
	 * @return the low key
	 */
	private XTCdeweyID readLowKey() {

		int lowIDLength = data[0] & 255;
		byte[] lowIDBytes = new byte[lowIDLength];
		System.arraycopy(data, 1, lowIDBytes, 0, lowIDLength);

		return new XTCdeweyID(null, lowIDBytes);
	}

	/**
	 * Returns the low key of this sequence.
	 * 
	 * @return the low key
	 */
	public XTCdeweyID getLowKey() {
		return lowKey;
	}

	/**
	 * @return bracket key type of the low key
	 */
	protected BracketKey.Type getLowKeyType() {
		int lowIDTypeField = 1 + (data[0] & 255);
		return BracketKey.Type.getByPhysicalValue(data[lowIDTypeField] & 255);
	}

	/**
	 * @return the start offset
	 */
	protected int getStartOffset() {
		return 2 + (data[0] & 255);
	}

	/**
	 * @return number of data records in this sequence
	 */
	public int getNumberOfDataRecords() {
		return numberOfDataRecords;
	}

	/**
	 * @return the internal byte representation of this sequence
	 */
	protected byte[] getData() {
		return data;
	}

	/**
	 * Sets the given DeweyIDBuffer to the last node stored in this bracket node
	 * sequence.
	 * 
	 * @param deweyIDbuffer
	 *            the DeweyIDBuffer to set
	 * @return the offset of the last node
	 */
	protected int setToLastNode(DeweyIDBuffer deweyIDbuffer) {

		deweyIDbuffer.setTo(lowKey);
		int currentOffset = getStartOffset() + getValueLength(LOW_KEY_OFFSET);

		BracketKey currentKey = new BracketKey();
		int lastNodeOffset = LOW_KEY_OFFSET;
		while (currentOffset < data.length) {
			lastNodeOffset = currentOffset;

			currentKey.load(data, currentOffset);
			deweyIDbuffer.update(currentKey, false);

			currentOffset += BracketKey.PHYSICAL_LENGTH;

			if (currentKey.hasDataReference()) {
				int valueLength = BracketPage.getValueLength(currentOffset,
						true, data);
				currentOffset += valueLength;
			}
		}
		return lastNodeOffset;
	}

	/**
	 * Returns the value length a given bracket node.
	 * 
	 * @param currentOffset
	 *            the offset where the bracket key starts
	 * @return the value length of the current node
	 */
	protected int getValueLength(int currentOffset) {

		int valueOffset = 0;

		if (currentOffset == LOW_KEY_OFFSET) {
			if (getLowKeyType().hasDataReference()) {
				valueOffset = getStartOffset();
			} else {
				return 0;
			}
		} else {
			if (BracketKey.loadType(data, currentOffset).hasDataReference()) {
				valueOffset = currentOffset + BracketKey.PHYSICAL_LENGTH;
			} else {
				return 0;
			}
		}

		return BracketPage.getValueLength(valueOffset, true, data);
	}

	/**
	 * @see java.lang.Object#toString()
	 */
	@Override
	public String toString() {
		if (data == null || data.length == 0) {
			return "Empty Chain";
		}

		final String outLine = "%s (%s B)\n";
		final String outLineNoData = "%s (no data)\n";
		StringBuilder out = new StringBuilder();
		int currentOffset = 0;

		// reconstruct LowID

		int lowIDLength = data[currentOffset] & 255;
		currentOffset++;
		byte[] lowIDBytes = new byte[lowIDLength];
		System.arraycopy(data, currentOffset, lowIDBytes, 0, lowIDLength);
		XTCdeweyID lowID = new XTCdeweyID(null, lowIDBytes);
		currentOffset += lowIDLength;
		BracketKey.Type lowIDType = BracketKey.Type
				.getByPhysicalValue(data[currentOffset]);
		currentOffset++;

		// print nodes

		DeweyIDBuffer currentDeweyID = new DeweyIDBuffer(null, lowID);
		BracketKey currentKey = new BracketKey();
		BracketKey.Type currentKeyType = lowIDType;
		boolean firstRun = true;

		while (currentOffset < data.length || firstRun) {
			if (!firstRun) {
				currentKey.load(data, currentOffset);
				currentKeyType = currentKey.type;
				currentDeweyID.update(currentKey, false);
				currentOffset += BracketKey.PHYSICAL_LENGTH;
			} else {
				firstRun = false;
			}

			if (currentKeyType != BracketKey.Type.OVERFLOW) {
				if (currentKeyType == BracketKey.Type.NODATA) {
					out.append(String.format(outLineNoData,
							currentDeweyID.getDeweyID()));
				} else {
					int valueLength = BracketPage.getValueLength(currentOffset,
							true, data);
					currentOffset += valueLength;
					out.append(String.format(outLine,
							currentDeweyID.getDeweyID(), valueLength));
				}
			}
		}

		return out.toString();
	}
}
